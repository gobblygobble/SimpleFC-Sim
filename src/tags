!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
A	controller.hpp	/^    int A;$/;"	m	class:Controller
B	controller.hpp	/^    int B;$/;"	m	class:Controller
BUFOBJS	Makefile	/^BUFOBJS = memory.cpp buffer.cpp test_buffer.cpp$/;"	m
Buffer	buffer.cpp	/^Buffer::Buffer(int _buffer_index, float _bw, float _bpc, int _capacity, Memory *_memory, UnifiedBuffer *_ub) {$/;"	f	class:Buffer
Buffer	buffer.hpp	/^class Buffer {$/;"	c
C	controller.hpp	/^    int C;$/;"	m	class:Controller
CC	Makefile	/^CC = g++$/;"	m
CFLAGS	Makefile	/^CFLAGS = -g$/;"	m
ChangeInReceiver	buffer.cpp	/^void UnifiedBuffer::ChangeInReceiver(int finished_index) {$/;"	f	class:UnifiedBuffer
ChangeInSender	buffer.cpp	/^void UnifiedBuffer::ChangeInSender(int finished_index) {$/;"	f	class:UnifiedBuffer
CheckExistenceInReadyQueue	buffer.cpp	/^bool UnifiedBuffer::CheckExistenceInReadyQueue(int order) {$/;"	f	class:UnifiedBuffer
CheckReadiness	mac.cpp	/^bool Mac::CheckReadiness(int order) {$/;"	f	class:Mac
Compute	mac.cpp	/^void Mac::Compute(int size) {$/;"	f	class:Mac
Controller	controller.cpp	/^Controller::Controller(Memory *_memory, UnifiedBuffer *_ub, Mac *_mac, float _clock) {$/;"	f	class:Controller
Controller	controller.hpp	/^class Controller {$/;"	c
Cycle	buffer.cpp	/^void Buffer::Cycle() {$/;"	f	class:Buffer
Cycle	buffer.cpp	/^void UnifiedBuffer::Cycle() {$/;"	f	class:UnifiedBuffer
Cycle	mac.cpp	/^void Mac::Cycle() {$/;"	f	class:Mac
Cycle	memory.cpp	/^void Memory::Cycle() {$/;"	f	class:Memory
DEBUG	controller.cpp	11;"	d	file:
DEBUG	mac.cpp	10;"	d	file:
DoingAbsolutelyNothing	buffer.cpp	/^bool UnifiedBuffer::DoingAbsolutelyNothing() {$/;"	f	class:UnifiedBuffer
DoingAbsolutelyNothing	mac.cpp	/^bool Mac::DoingAbsolutelyNothing() {$/;"	f	class:Mac
GetBandwidth	buffer.cpp	/^float Buffer::GetBandwidth() {$/;"	f	class:Buffer
GetBandwidth	memory.cpp	/^float Memory::GetBandwidth() {$/;"	f	class:Memory
GetBusyCycle	buffer.cpp	/^int Buffer::GetBusyCycle() {$/;"	f	class:Buffer
GetBusyCycle	mac.hpp	/^    int GetBusyCycle() {return busy_cycle;}$/;"	f	class:Mac
GetBusyCycle	memory.cpp	/^int Memory::GetBusyCycle() {$/;"	f	class:Memory
GetBytesPerCycle	buffer.cpp	/^float Buffer::GetBytesPerCycle() {$/;"	f	class:Buffer
GetBytesPerCycle	buffer.hpp	/^    float GetBytesPerCycle() {return bpc;};$/;"	f	class:UnifiedBuffer
GetBytesPerCycle	memory.cpp	/^float Memory::GetBytesPerCycle() {$/;"	f	class:Memory
GetBytesToReceive	buffer.cpp	/^float Buffer::GetBytesToReceive() {$/;"	f	class:Buffer
GetBytesToSend	buffer.cpp	/^float Buffer::GetBytesToSend() {$/;"	f	class:Buffer
GetBytesToSendBuffer1	memory.cpp	/^float Memory::GetBytesToSendBuffer1() {$/;"	f	class:Memory
GetBytesToSendBuffer2	memory.cpp	/^float Memory::GetBytesToSendBuffer2() {$/;"	f	class:Memory
GetBytesToSendTotal	memory.cpp	/^float Memory::GetBytesToSendTotal() {$/;"	f	class:Memory
GetCapacity	buffer.hpp	/^    int GetCapacity() {return capacity;}$/;"	f	class:UnifiedBuffer
GetFirstBufferPointer	buffer.hpp	/^    Buffer* GetFirstBufferPointer() {return buffer1;}$/;"	f	class:UnifiedBuffer
GetFirstBufferPointer	mac.hpp	/^    Buffer *GetFirstBufferPointer() {return buffer1;}$/;"	f	class:Mac
GetIdleCycle	buffer.cpp	/^int Buffer::GetIdleCycle() {$/;"	f	class:Buffer
GetIdleCycle	mac.hpp	/^    int GetIdleCycle() {return idle_cycle;}$/;"	f	class:Mac
GetIdleCycle	memory.cpp	/^int Memory::GetIdleCycle() {$/;"	f	class:Memory
GetLatestSendIndex	buffer.hpp	/^    int GetLatestSendIndex() {return latest_send_index;}$/;"	f	class:UnifiedBuffer
GetMacPointer	buffer.hpp	/^    Mac *GetMacPointer() {return mac;}$/;"	f	class:UnifiedBuffer
GetMemoryPointer	buffer.hpp	/^    Memory *GetMemoryPointer(){return memory;}$/;"	f	class:UnifiedBuffer
GetPower	mac.hpp	/^    int GetPower() {return power;}$/;"	f	class:Mac
GetSecondBufferPointer	buffer.hpp	/^    Buffer* GetSecondBufferPointer() {return buffer2;}$/;"	f	class:UnifiedBuffer
GetSecondBufferPointer	mac.hpp	/^    Buffer *GetSecondBufferPointer() {return buffer2;}$/;"	f	class:Mac
GetServicingBuffer	memory.cpp	/^int Memory::GetServicingBuffer() {$/;"	f	class:Memory
GetTotalCycle	buffer.cpp	/^int Buffer::GetTotalCycle() {$/;"	f	class:Buffer
GetTotalCycle	mac.hpp	/^    int GetTotalCycle() {return busy_cycle + idle_cycle;}$/;"	f	class:Mac
GetTotalCycle	memory.cpp	/^int Memory::GetTotalCycle() {$/;"	f	class:Memory
GetTotalOperations	controller.hpp	/^    int GetTotalOperations() {return 2 * A * B * C;}$/;"	f	class:Controller
GetUnifiedBufferPointer	mac.hpp	/^    UnifiedBuffer *GetUnifiedBufferPointer() {return ub;}$/;"	f	class:Mac
GreatestCommonDivisor	controller.cpp	/^int Controller::GreatestCommonDivisor(int x, int y) {$/;"	f	class:Controller
HandleQueue	buffer.cpp	/^void UnifiedBuffer::HandleQueue() {$/;"	f	class:UnifiedBuffer
IsComputing	mac.cpp	/^bool Mac::IsComputing() {$/;"	f	class:Mac
IsIdle	buffer.cpp	/^bool Buffer::IsIdle() {$/;"	f	class:Buffer
IsIdle	buffer.cpp	/^bool UnifiedBuffer::IsIdle() {$/;"	f	class:UnifiedBuffer
IsIdle	mac.cpp	/^bool Mac::IsIdle() {$/;"	f	class:Mac
IsIdle	memory.cpp	/^bool Memory::IsIdle() {$/;"	f	class:Memory
IsNotReceiving	buffer.cpp	/^bool UnifiedBuffer::IsNotReceiving() {$/;"	f	class:UnifiedBuffer
IsReceiving	buffer.cpp	/^bool Buffer::IsReceiving() {$/;"	f	class:Buffer
IsSending	buffer.cpp	/^bool Buffer::IsSending() {$/;"	f	class:Buffer
MACOBJS	Makefile	/^MACOBJS = memory.cpp buffer.cpp mac.cpp test_mac.cpp$/;"	m
MEMOBJS	Makefile	/^MEMOBJS = memory.cpp test_memory.cpp$/;"	m
Mac	mac.cpp	/^Mac::Mac(UnifiedBuffer *_ub, float _power, float _clock) {$/;"	f	class:Mac
Mac	mac.hpp	/^class Mac {$/;"	c
MacUsingChunk	buffer.cpp	/^void UnifiedBuffer::MacUsingChunk(int order) {$/;"	f	class:UnifiedBuffer
MatrixMultiply	controller.cpp	/^void Controller::MatrixMultiply(int _A, int _B, int _C) {$/;"	f	class:Controller
Memory	memory.cpp	/^Memory::Memory(float clock, float _bw) {$/;"	f	class:Memory
Memory	memory.hpp	/^class Memory {$/;"	c
NotifyChangeInReceiver	buffer.cpp	/^void Buffer::NotifyChangeInReceiver(int finished_index) {$/;"	f	class:Buffer
NotifyChangeInSender	buffer.cpp	/^void Buffer::NotifyChangeInSender(int finished_index) {$/;"	f	class:Buffer
OBJS	Makefile	/^OBJS = memory.cpp buffer.cpp mac.cpp controller.cpp main.cpp$/;"	m
PrintStats	buffer.cpp	/^void Buffer::PrintStats() {$/;"	f	class:Buffer
PrintStats	buffer.cpp	/^void UnifiedBuffer::PrintStats() {$/;"	f	class:UnifiedBuffer
PrintStats	mac.cpp	/^void Mac::PrintStats() {$/;"	f	class:Mac
PrintStats	memory.cpp	/^void Memory::PrintStats() {$/;"	f	class:Memory
ReceiveDoneSignal	buffer.cpp	/^void UnifiedBuffer::ReceiveDoneSignal(int rcv_buffer_index, bool pending) {$/;"	f	class:UnifiedBuffer
ReceiveRequest	buffer.cpp	/^void Buffer::ReceiveRequest(float _bts) {$/;"	f	class:Buffer
ReceiveRequest	buffer.cpp	/^void UnifiedBuffer::ReceiveRequest(float _bts, int req_num) {$/;"	f	class:UnifiedBuffer
ReceiveRequest	mac.cpp	/^void Mac::ReceiveRequest(float _btr) {$/;"	f	class:Mac
ReceiveRequest	memory.cpp	/^void Memory::ReceiveRequest(int bufnum, float _bts) {$/;"	f	class:Memory
SendRequest	buffer.cpp	/^void Buffer::SendRequest(float _btr) {$/;"	f	class:Buffer
SendRequest	buffer.cpp	/^void UnifiedBuffer::SendRequest(float _btr, int req_number) {$/;"	f	class:UnifiedBuffer
SendRequestToMac	controller.cpp	/^void Controller::SendRequestToMac() {$/;"	f	class:Controller
SetBringIn	buffer.cpp	/^void Buffer::SetBringIn(bool flag, float size) {$/;"	f	class:Buffer
SetBringOut	buffer.cpp	/^void Buffer::SetBringOut(bool flag) {$/;"	f	class:Buffer
SetBufferConnection	memory.cpp	/^void Memory::SetBufferConnection(UnifiedBuffer *_buffer) {$/;"	f	class:Memory
SetMacConnection	buffer.cpp	/^void UnifiedBuffer::SetMacConnection(Mac *_mac) {$/;"	f	class:UnifiedBuffer
SignalDoneReceiving	memory.cpp	/^void Memory::SignalDoneReceiving(int finished_index) {$/;"	f	class:Memory
SignalUsing	mac.cpp	/^void Mac::SignalUsing(int order) {$/;"	f	class:Mac
Tile	controller.cpp	/^void Controller::Tile() {$/;"	f	class:Controller
UnifiedBuffer	buffer.cpp	/^UnifiedBuffer::UnifiedBuffer(float clock, float _bw, int _capacity, Memory *_memory) {$/;"	f	class:UnifiedBuffer
UnifiedBuffer	buffer.hpp	/^class UnifiedBuffer {$/;"	c
UpdateLatestReceivedIndex	buffer.cpp	/^void UnifiedBuffer::UpdateLatestReceivedIndex(int finished_index) {$/;"	f	class:UnifiedBuffer
UpdateLatestSentIndex	buffer.cpp	/^void UnifiedBuffer::UpdateLatestSentIndex(int finished_index) {$/;"	f	class:UnifiedBuffer
a	controller.hpp	/^    int a;$/;"	m	class:Controller
b	controller.hpp	/^    int b;$/;"	m	class:Controller
bpc	buffer.hpp	/^    float bpc;                      \/\/ bytes per clock, bw\/clock(frequency)$/;"	m	class:UnifiedBuffer
bpc	buffer.hpp	/^    float bpc;          \/\/ bytes per clock, bw\/clock(frequency)$/;"	m	class:Buffer
bpc	mac.hpp	/^    float bpc;                      \/\/ bytes per cycle, serviced by buffer to MAC$/;"	m	class:Mac
bpc	memory.hpp	/^    float bpc;              \/\/ bytes per clock, bw\/clock(frequency)$/;"	m	class:Memory
bring_in	buffer.hpp	/^    bool bring_in;      \/\/ whether it is receiving data from Memory$/;"	m	class:Buffer
bring_out	buffer.hpp	/^    bool bring_out;     \/\/ whether it is sending data to MAC$/;"	m	class:Buffer
btr	buffer.hpp	/^    float btr;          \/\/ bytes to receive (remaining) from memory$/;"	m	class:Buffer
btr	mac.hpp	/^    float btr;                      \/\/ number of bytes left to receive$/;"	m	class:Mac
bts	buffer.hpp	/^    float bts;          \/\/ bytes to send (remaining) for MAC$/;"	m	class:Buffer
bts1	memory.hpp	/^    float bts1;             \/\/ bytes to send (remaining) for buffer1$/;"	m	class:Memory
bts2	memory.hpp	/^    float bts2;             \/\/ bytes to send (remaining) for buffer2$/;"	m	class:Memory
buffer	memory.hpp	/^    UnifiedBuffer *buffer;  \/\/ pointer to buffer connected to this memory, NOT connected in constructor!$/;"	m	class:Memory
buffer1	buffer.hpp	/^    Buffer *buffer1;                \/\/ pointer to first buffer$/;"	m	class:UnifiedBuffer
buffer1	mac.hpp	/^    Buffer *buffer1;                \/\/ pointer to first buffer of unified buffer$/;"	m	class:Mac
buffer2	buffer.hpp	/^    Buffer *buffer2;                \/\/ pointer to second buffer$/;"	m	class:UnifiedBuffer
buffer2	mac.hpp	/^    Buffer *buffer2;                \/\/ pointer to second buffer of unified buffer$/;"	m	class:Mac
buffer_index	buffer.hpp	/^    int buffer_index;   \/\/ index of buffer - 1 or 2$/;"	m	class:Buffer
buffer_size	controller.hpp	/^    int buffer_size;$/;"	m	class:Controller
busy_cycle	buffer.hpp	/^    int busy_cycle;                 \/\/ number of cycles that either one of the two buffers were busy (sending)$/;"	m	class:UnifiedBuffer
busy_cycle	buffer.hpp	/^    int busy_cycle;     \/\/ number of busy cycles (sending)$/;"	m	class:Buffer
busy_cycle	mac.hpp	/^    int busy_cycle;                 \/\/ number of cycles that MAC was serviced by any of the buffers$/;"	m	class:Mac
busy_cycle	memory.hpp	/^    int busy_cycle;         \/\/ number of busy cycles$/;"	m	class:Memory
bw	buffer.hpp	/^    float bw;                       \/\/ bandwidth from buffer to MAC$/;"	m	class:UnifiedBuffer
bw	buffer.hpp	/^    float bw;           \/\/ bandwidth from buffer to MAC$/;"	m	class:Buffer
bw	memory.hpp	/^    float bw;               \/\/ bandwidth from memory to buffer in GB\/s$/;"	m	class:Memory
c	controller.hpp	/^    int c;$/;"	m	class:Controller
capacity	buffer.hpp	/^    int capacity;                   \/\/ total capacity of unified buffer$/;"	m	class:UnifiedBuffer
capacity	buffer.hpp	/^    int capacity;       \/\/ size of capacity in MB$/;"	m	class:Buffer
clock	controller.hpp	/^    float clock;$/;"	m	class:Controller
clock	mac.hpp	/^    float clock;                    \/\/ frequency, in GHz (cycles per second)$/;"	m	class:Mac
computed	mac.hpp	/^    bool computed;                  \/\/ whether MAC has performed computation this cycle$/;"	m	class:Mac
idle_cycle	buffer.hpp	/^    int idle_cycle;                 \/\/ number of cycles that both of the buffers were idle (not sending)$/;"	m	class:UnifiedBuffer
idle_cycle	buffer.hpp	/^    int idle_cycle;     \/\/ number of idle cycles$/;"	m	class:Buffer
idle_cycle	mac.hpp	/^    int idle_cycle;                 \/\/ number of cycles that MAC was left unserviced$/;"	m	class:Mac
idle_cycle	memory.hpp	/^    int idle_cycle;         \/\/ number of idle cycles$/;"	m	class:Memory
latest_rcv_index	buffer.hpp	/^    int latest_rcv_index;           \/\/ index of buffer that has finished receiving latest$/;"	m	class:UnifiedBuffer
latest_send_index	buffer.hpp	/^    int latest_send_index;          \/\/ index of buffer that has finished sending latest$/;"	m	class:UnifiedBuffer
mac	buffer.hpp	/^    Mac *mac;                       \/\/ pointer to macconnected to this buffer$/;"	m	class:UnifiedBuffer
mac	controller.hpp	/^    Mac *mac;$/;"	m	class:Controller
main	main.cpp	/^int main(int argc, char* argv[]) {$/;"	f
main	test_buffer.cpp	/^int main(int argc, char* argv[]) {$/;"	f
main	test_mac.cpp	/^int main(int argc, char* argv[]) {$/;"	f
main	test_memory.cpp	/^int main(int argc, char* argv[]) {$/;"	f
memory	buffer.hpp	/^    Memory *memory;                 \/\/ pointer to memory connected to this buffer$/;"	m	class:UnifiedBuffer
memory	buffer.hpp	/^    Memory *memory;     \/\/ pointer to memory connected to this buffer$/;"	m	class:Buffer
memory	controller.hpp	/^    Memory* memory;$/;"	m	class:Controller
order	buffer.hpp	/^    int order;$/;"	m	struct:request
pending_receive	buffer.hpp	/^    bool pending_receive;           \/\/ whether data to receive exists after the current receiving wave$/;"	m	class:UnifiedBuffer
pending_send	buffer.hpp	/^    bool pending_send;              \/\/ whether data to send exists after the current sending wave$/;"	m	class:UnifiedBuffer
power	controller.hpp	/^    int power;$/;"	m	class:Controller
power	mac.hpp	/^    int power;                    \/\/ number of small MAC units$/;"	m	class:Mac
rcv_buffer	buffer.hpp	/^    int rcv_buffer;                 \/\/ index of buffer receiving data from memory$/;"	m	class:UnifiedBuffer
rcv_buffer	memory.hpp	/^    int rcv_buffer;         \/\/ buffer being serviced atm - 0 if none.$/;"	m	class:Memory
ready_queue	buffer.hpp	/^    std::queue <int> ready_queue; \/\/ queue of requests ready to send to MAC$/;"	m	class:UnifiedBuffer
receiving_req_num	buffer.hpp	/^    int receiving_req_num;          \/\/ current number of request being serviced$/;"	m	class:UnifiedBuffer
remaining_computation	mac.hpp	/^    int remaining_computation;      \/\/ how much of computation left (not 2x-ed)$/;"	m	class:Mac
req	buffer.hpp	/^typedef struct request req;$/;"	t	typeref:struct:request
req_num	mac.hpp	/^    int req_num;                    \/\/ index to give to the next generated request$/;"	m	class:Mac
req_queue	buffer.hpp	/^    std::queue <req> req_queue;     \/\/ queue of requests to send to memory$/;"	m	class:UnifiedBuffer
req_queue	mac.hpp	/^    std::queue <req> req_queue;     \/\/ queue of requests to send to buffer$/;"	m	class:Mac
request	buffer.hpp	/^struct request {$/;"	s
send_buffer	buffer.hpp	/^    int send_buffer;                \/\/ index of buffer sending data to MAC$/;"	m	class:UnifiedBuffer
size	buffer.hpp	/^    float size;$/;"	m	struct:request
stall_cycle	mac.hpp	/^    int stall_cycle;                \/\/ number of cycles that a request was stalled$/;"	m	class:Mac
ub	buffer.hpp	/^    UnifiedBuffer *ub;  \/\/ pointer to unified buffer, which includes this buffer$/;"	m	class:Buffer
ub	controller.hpp	/^    UnifiedBuffer *ub;$/;"	m	class:Controller
ub	mac.hpp	/^    UnifiedBuffer *ub;              \/\/ pointer to unified buffer connected with this buffer$/;"	m	class:Mac
wait_queue	mac.hpp	/^    std::queue <req> wait_queue;    \/\/ queue of requests waiting to be received$/;"	m	class:Mac
