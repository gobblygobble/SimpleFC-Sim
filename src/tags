!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BUFOBJS	Makefile	/^BUFOBJS = memory.cpp buffer.cpp test_buffer.cpp$/;"	m
Buffer	buffer.cpp	/^Buffer::Buffer(int _buffer_index, float _bw, float _bpc, int _capacity, Memory *_memory, UnifiedBuffer *_ub) {$/;"	f	class:Buffer
Buffer	buffer.hpp	/^class Buffer {$/;"	c
CC	Makefile	/^CC = g++$/;"	m
ChangeInReceiver	buffer.cpp	/^void UnifiedBuffer::ChangeInReceiver(int finished_index) {$/;"	f	class:UnifiedBuffer
ChangeInSender	buffer.cpp	/^void UnifiedBuffer::ChangeInSender(int finished_index) {$/;"	f	class:UnifiedBuffer
Cycle	buffer.cpp	/^void Buffer::Cycle() {$/;"	f	class:Buffer
Cycle	buffer.cpp	/^void UnifiedBuffer::Cycle() {$/;"	f	class:UnifiedBuffer
Cycle	memory.cpp	/^void Memory::Cycle() {$/;"	f	class:Memory
DEBUG	buffer.cpp	10;"	d	file:
DEBUG	memory.cpp	8;"	d	file:
DoingAbsolutelyNothing	buffer.cpp	/^bool UnifiedBuffer::DoingAbsolutelyNothing() {$/;"	f	class:UnifiedBuffer
GetBandwidth	buffer.cpp	/^float Buffer::GetBandwidth() {$/;"	f	class:Buffer
GetBandwidth	memory.cpp	/^float Memory::GetBandwidth() {$/;"	f	class:Memory
GetBusyCycle	buffer.cpp	/^int Buffer::GetBusyCycle() {$/;"	f	class:Buffer
GetBusyCycle	memory.cpp	/^int Memory::GetBusyCycle() {$/;"	f	class:Memory
GetBytesPerCycle	buffer.cpp	/^float Buffer::GetBytesPerCycle() {$/;"	f	class:Buffer
GetBytesPerCycle	memory.cpp	/^float Memory::GetBytesPerCycle() {$/;"	f	class:Memory
GetBytesToReceive	buffer.cpp	/^float Buffer::GetBytesToReceive() {$/;"	f	class:Buffer
GetBytesToSend	buffer.cpp	/^float Buffer::GetBytesToSend() {$/;"	f	class:Buffer
GetBytesToSendBuffer1	memory.cpp	/^float Memory::GetBytesToSendBuffer1() {$/;"	f	class:Memory
GetBytesToSendBuffer2	memory.cpp	/^float Memory::GetBytesToSendBuffer2() {$/;"	f	class:Memory
GetBytesToSendTotal	memory.cpp	/^float Memory::GetBytesToSendTotal() {$/;"	f	class:Memory
GetIdleCycle	buffer.cpp	/^int Buffer::GetIdleCycle() {$/;"	f	class:Buffer
GetIdleCycle	memory.cpp	/^int Memory::GetIdleCycle() {$/;"	f	class:Memory
GetMemoryPointer	buffer.hpp	/^    Memory *GetMemoryPointer(){return memory;}$/;"	f	class:UnifiedBuffer
GetServicingBuffer	memory.cpp	/^int Memory::GetServicingBuffer() {$/;"	f	class:Memory
GetTotalCycle	buffer.cpp	/^int Buffer::GetTotalCycle() {$/;"	f	class:Buffer
GetTotalCycle	memory.cpp	/^int Memory::GetTotalCycle() {$/;"	f	class:Memory
HandleQueue	buffer.cpp	/^void UnifiedBuffer::HandleQueue() {$/;"	f	class:UnifiedBuffer
IsIdle	buffer.cpp	/^bool Buffer::IsIdle() {$/;"	f	class:Buffer
IsIdle	buffer.cpp	/^bool UnifiedBuffer::IsIdle() {$/;"	f	class:UnifiedBuffer
IsIdle	memory.cpp	/^bool Memory::IsIdle() {$/;"	f	class:Memory
IsNotReceiving	buffer.cpp	/^bool UnifiedBuffer::IsNotReceiving() {$/;"	f	class:UnifiedBuffer
IsReceiving	buffer.cpp	/^bool Buffer::IsReceiving() {$/;"	f	class:Buffer
IsSending	buffer.cpp	/^bool Buffer::IsSending() {$/;"	f	class:Buffer
MACOBJS	Makefile	/^MACOBJS = mac.cpp test_mac.cpp$/;"	m
MEMOBJS	Makefile	/^MEMOBJS = memory.cpp test_memory.cpp$/;"	m
Memory	memory.cpp	/^Memory::Memory(float clock, float _bw) {$/;"	f	class:Memory
Memory	memory.hpp	/^class Memory {$/;"	c
NotifyChangeInReceiver	buffer.cpp	/^void Buffer::NotifyChangeInReceiver(int finished_index) {$/;"	f	class:Buffer
NotifyChangeInSender	buffer.cpp	/^void Buffer::NotifyChangeInSender(int finished_index) {$/;"	f	class:Buffer
PrintStats	buffer.cpp	/^void Buffer::PrintStats() {$/;"	f	class:Buffer
PrintStats	buffer.cpp	/^void UnifiedBuffer::PrintStats() {$/;"	f	class:UnifiedBuffer
PrintStats	memory.cpp	/^void Memory::PrintStats() {$/;"	f	class:Memory
ReceiveDoneSignal	buffer.cpp	/^void UnifiedBuffer::ReceiveDoneSignal(int rcv_buffer_index, bool pending) {$/;"	f	class:UnifiedBuffer
ReceiveRequest	buffer.cpp	/^void Buffer::ReceiveRequest(float _bts) {$/;"	f	class:Buffer
ReceiveRequest	buffer.cpp	/^void UnifiedBuffer::ReceiveRequest(float _bts) {$/;"	f	class:UnifiedBuffer
ReceiveRequest	memory.cpp	/^void Memory::ReceiveRequest(int bufnum, float _bts) {$/;"	f	class:Memory
SendRequest	buffer.cpp	/^void Buffer::SendRequest(float _btr) {$/;"	f	class:Buffer
SendRequest	buffer.cpp	/^void UnifiedBuffer::SendRequest(float _btr) {$/;"	f	class:UnifiedBuffer
SetBringIn	buffer.cpp	/^void Buffer::SetBringIn(bool flag) {$/;"	f	class:Buffer
SetBringOut	buffer.cpp	/^void Buffer::SetBringOut(bool flag) {$/;"	f	class:Buffer
SetBufferConnection	memory.cpp	/^void Memory::SetBufferConnection(UnifiedBuffer *_buffer) {$/;"	f	class:Memory
SignalDoneReceiving	memory.cpp	/^void Memory::SignalDoneReceiving(int finished_index) {$/;"	f	class:Memory
UnifiedBuffer	buffer.cpp	/^UnifiedBuffer::UnifiedBuffer(float clock, float _bw, int _capacity, Memory *_memory) {$/;"	f	class:UnifiedBuffer
UnifiedBuffer	buffer.hpp	/^class UnifiedBuffer {$/;"	c
UpdateLatestReceivedIndex	buffer.cpp	/^void UnifiedBuffer::UpdateLatestReceivedIndex(int finished_index) {$/;"	f	class:UnifiedBuffer
UpdateLatestSentIndex	buffer.cpp	/^void UnifiedBuffer::UpdateLatestSentIndex(int finished_index) {$/;"	f	class:UnifiedBuffer
bpc	buffer.hpp	/^    float bpc;                      \/\/ bytes per clock, bw\/clock(frequency)$/;"	m	class:UnifiedBuffer
bpc	buffer.hpp	/^    float bpc;          \/\/ bytes per clock, bw\/clock(frequency)$/;"	m	class:Buffer
bpc	memory.hpp	/^    float bpc;              \/\/ bytes per clock, bw\/clock(frequency)$/;"	m	class:Memory
bring_in	buffer.hpp	/^    bool bring_in;      \/\/ whether it is receiving data from Memory$/;"	m	class:Buffer
bring_out	buffer.hpp	/^    bool bring_out;     \/\/ whether it is sending data to MAC$/;"	m	class:Buffer
btr	buffer.hpp	/^    float btr;          \/\/ bytes to receive (remaining) from memory$/;"	m	class:Buffer
bts	buffer.hpp	/^    float bts;          \/\/ bytes to send (remaining) for MAC$/;"	m	class:Buffer
bts1	memory.hpp	/^    float bts1;             \/\/ bytes to send (remaining) for buffer1$/;"	m	class:Memory
bts2	memory.hpp	/^    float bts2;             \/\/ bytes to send (remaining) for buffer2$/;"	m	class:Memory
buffer	memory.hpp	/^    UnifiedBuffer *buffer;  \/\/ pointer to buffer connected to this memory, NOT connected in constructor!$/;"	m	class:Memory
buffer1	buffer.hpp	/^    Buffer *buffer1;                \/\/ pointer to first buffer$/;"	m	class:UnifiedBuffer
buffer2	buffer.hpp	/^    Buffer *buffer2;                \/\/ pointer to second buffer$/;"	m	class:UnifiedBuffer
buffer_index	buffer.hpp	/^    int buffer_index;   \/\/ index of buffer - 1 or 2$/;"	m	class:Buffer
busy_cycle	buffer.hpp	/^    int busy_cycle;                 \/\/ number of cycles that either one of the two buffers were busy (sending)$/;"	m	class:UnifiedBuffer
busy_cycle	buffer.hpp	/^    int busy_cycle;     \/\/ number of busy cycles (sending)$/;"	m	class:Buffer
busy_cycle	memory.hpp	/^    int busy_cycle;         \/\/ number of busy cycles$/;"	m	class:Memory
bw	buffer.hpp	/^    float bw;                       \/\/ bandwidth from buffer to MAC$/;"	m	class:UnifiedBuffer
bw	buffer.hpp	/^    float bw;           \/\/ bandwidth from buffer to MAC$/;"	m	class:Buffer
bw	memory.hpp	/^    float bw;               \/\/ bandwidth from memory to buffer in GB\/s$/;"	m	class:Memory
capacity	buffer.hpp	/^    int capacity;                   \/\/ total capacity of unified buffer$/;"	m	class:UnifiedBuffer
capacity	buffer.hpp	/^    int capacity;       \/\/ size of capacity in MB$/;"	m	class:Buffer
idle_cycle	buffer.hpp	/^    int idle_cycle;                 \/\/ number of cycles that both of the buffers were idle (not sending)$/;"	m	class:UnifiedBuffer
idle_cycle	buffer.hpp	/^    int idle_cycle;     \/\/ number of idle cycles$/;"	m	class:Buffer
idle_cycle	memory.hpp	/^    int idle_cycle;         \/\/ number of idle cycles$/;"	m	class:Memory
latest_rcv_index	buffer.hpp	/^    int latest_rcv_index;           \/\/ index of buffer that has finished receiving latest$/;"	m	class:UnifiedBuffer
latest_send_index	buffer.hpp	/^    int latest_send_index;          \/\/ index of buffer that has finished sending latest$/;"	m	class:UnifiedBuffer
main	test_buffer.cpp	/^int main(int argc, char* argv[]) {$/;"	f
main	test_memory.cpp	/^int main(int argc, char* argv[]) {$/;"	f
memory	buffer.hpp	/^    Memory *memory;                 \/\/ pointer to memory connected to this buffer$/;"	m	class:UnifiedBuffer
memory	buffer.hpp	/^    Memory *memory;     \/\/ pointer to memory connected to this buffer$/;"	m	class:Buffer
pending_receive	buffer.hpp	/^    bool pending_receive;           \/\/ whether data to receive exists after the current receiving wave$/;"	m	class:UnifiedBuffer
pending_send	buffer.hpp	/^    bool pending_send;              \/\/ whether data to send exists after the current sending wave$/;"	m	class:UnifiedBuffer
rcv_buffer	buffer.hpp	/^    int rcv_buffer;                 \/\/ index of buffer receiving data from memory$/;"	m	class:UnifiedBuffer
rcv_buffer	memory.hpp	/^    int rcv_buffer;         \/\/ buffer being serviced atm - 0 if none.$/;"	m	class:Memory
req_queue	buffer.hpp	/^    std::queue <float> req_queue;   \/\/ queue of requests to send to memory$/;"	m	class:UnifiedBuffer
send_buffer	buffer.hpp	/^    int send_buffer;                \/\/ index of buffer sending data to MAC$/;"	m	class:UnifiedBuffer
ub	buffer.hpp	/^    UnifiedBuffer *ub;  \/\/ pointer to unified buffer, which includes this buffer$/;"	m	class:Buffer
